"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.Follow = Follow;

var _require = require("./tracker");

var Dep = _require.Dep;
var autorun = _require.autorun;

// variables.js
//
// Reactive variable implmentations based on Tracker,
// and some JavaScript helpers.
//
// We avoid `this` altogether here, in order to be able to pass
// all the methods freely around. This is important in order to
// avoid template boilerplate.

function shortcut(kind) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new (Function.prototype.bind.apply(kind, [null].concat(args)))();
  };
}

var $ = exports.$ = shortcut(ZVar),
    Dict = exports.Dict = shortcut(ZDict);

// Return a reactive variable, which tracks changes using tracker,
// so that it functions as a reactive source.
function ZVar(value) {
  var dep = Dep(),
      defaultValue = value;

  // Return the current value of the variable
  function get() {
    dep.depend();
    return value;
  }

  // Set the current value of the variable
  function set(val) {
    if (value === val) return;
    value = val;
    dep.changed();
  }

  // Depend reactively on this variable inside tracker.autorun.
  function depend() {
    dep.depend();
  }

  // Reset this variable to the value that was initially
  // passed to the constructor.
  function reset() {
    set(defaultValue);
  }

  // Boolean convenience method.
  function toggle() {
    set(!value);
  }

  // Integer convenience method.
  function inc() {
    dep.changed();
    return ++value;
  }

  // Integer convenience method.
  function dec() {
    dep.changed();
    return --value;
  }

  // Array convenience method.
  function push(val) {
    dep.changed();
    value.push(val);
  }

  // Array convenience method.
  function pop(val) {
    if (value.length > 0) dep.changed();
    return value.pop();
  }

  // Array convenience method.
  function unshift(val) {
    dep.changed();
    value.unshift(val);
  }

  // Array convenience method.
  function shift(val) {
    if (value.length > 0) dep.changed();
    return value.shift();
  }

  // Array convenience method
  function length() {
    dep.depend();
    return value.length;
  }

  // Array convenience method
  function filter(fn) {
    value = value.filter(fn);
    dep.changed();
  }

  // Array convenience method
  function drop(item) {
    filter(function (e) {
      return e !== item;
    });
  }

  // Reset this variable, and return the value that was overwritten.
  function consume() {
    var result = value;
    reset();
    return result;
  }

  Object.assign(this, {
    set: set, depend: depend, get: get,
    reset: reset, consume: consume,
    toggle: toggle,
    inc: inc, dec: dec,
    push: push, pop: pop, unshift: unshift, shift: shift, length: length, filter: filter, drop: drop
  });
}

// Reactive dictionary. Experimental feature.
function ZDict(_vals) {
  var deps = {},
      vals = _extends({}, _vals);

  function set(name, val) {
    if (vals[name] === val) return;
    deps[name] = deps[name] || Dep();
    deps[name].changed();
    vals[name] = val;
  }

  function get(name) {
    deps[name] = deps[name] || Dep();
    deps[name].depend();
    return vals[name];
  }
  Object.assign(this, {
    set: set, get: get
  });
}

// Returns a reactive variable that will change to the value of a reactive getter whenever the getter changes. It can however be set to other values inbetween, without affecting the source of the getter.
function Follow(getter) {
  var result = $(1);
  autorun(function () {
    return result.set(getter());
  });
  return result;
}