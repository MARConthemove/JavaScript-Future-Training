"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.LocalStorage = LocalStorage;
exports.deserialize = deserialize;
exports.dump = dump;

var _require = require("./tracker");

var autorun = _require.autorun;

var _require2 = require("./variables");

var $ = _require2.$;

// Provides saving, reloading and save state tracking of a reactive variable given a getter and a setter to persist and load the state.
//  Note that the Persister will not mark the item changed until the tracker has flushed. you have to flush before checking for changes. This is usually not a problem in practice as long as the architecture is good.

function Persist(state, _ref) {
  var load = _ref.load;
  var _save = _ref.save;

  var saved = $(false);
  state.set(load());

  autorun(function () {
    state.depend();
    saved.set(false);
  });

  saved.set(true);

  return {
    save: function save() {
      _save(state);
      saved.set(true);
    },
    reload: function reload() {
      return state.set(load());
    },
    saved: saved
  };
}

// localStorage adapter that can be used with Persist
exports.Persist = Persist;
function LocalStorage(key) {
  return {
    load: function load() {
      var val = localStorage.getItem(key);
      return val === undefined ? undefined : JSON.parse(val);
    },

    save: function save(state) {
      return localStorage.setItem(key, JSON.stringify(state));
    }
  };
}

function _is(obj, kind) {
  var toString = Object.prototype.toString;
  return toString.call(obj) === ["[object ", kind, "]"].join("");
}

function deserialize(val) {
  if (val == "__$isZUNDEF") return undefined;
  if (val.__$isZV === 1) return $(deserialize(val.v));else if (_is(val, "Array")) return val.map(deserialize);else if (val.constructor === Object) {
    var _ret = function () {
      var result = {};
      Object.keys(val).forEach(function (k) {
        return result[k] = deserialize(val[k]);
      });
      return {
        v: result
      };
    }();

    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
  } else return val;
}

function dump(val) {
  if (val == undefined) return "__$isZUNDEF";
  if (val.constructor.name === "ZVar") return {
    __$isZV: 1,
    v: dump(val.get())
  };else if (_is(val, "Array")) return val.map(dump);else if (val.constructor === Object) {
    var _ret2 = function () {
      var result = {};
      Object.keys(val).forEach(function (k) {
        return result[k] = dump(val[k]);
      });
      return {
        v: result
      };
    }();

    if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
  } else return val;
}

// Serializer that can wrap a reactive variable in order
// to convert its underlying structure to valid JSON.

function SerializeTo(_ref2) {
  var _load = _ref2.load;
  var _save2 = _ref2.save;

  return {
    load: function load() {
      return deserialize(_load());
    },
    save: function save(val) {
      return _save2(dump(val));
    }
  };
}
exports.SerializeTo = SerializeTo;