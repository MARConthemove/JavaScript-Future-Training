/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var tracker = __webpack_require__(1),
	    templates = __webpack_require__(2),
	    variables = __webpack_require__(3),
	    serialization = __webpack_require__(4),
	    utils = __webpack_require__(5);

	var Zodiac = _extends({}, tracker, templates, variables, serialization, utils);

	module.exports = Zodiac;

	if (typeof window !== "undefined") window.Zodiac = Zodiac;

/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";

	/////////////////////////////////////////////////////
	// Package docs at http://docs.meteor.com/#tracker //
	/////////////////////////////////////////////////////

	// This file is copied straight from the Meteor framework.

	// ========================================
	//     Meteor is licensed under the MIT License
	// ========================================
	//
	//     Copyright (C) 2011--2016 Meteor Development Group
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	//
	//     The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	//
	//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	//
	//
	// ====================================================================
	// This license applies to all code in Meteor that is not an externally
	// maintained library. Externally maintained libraries have their own
	// licenses, included in the LICENSES directory.
	// ====================================================================

	/**
	 * @namespace Tracker
	 * @summary The namespace for Tracker-related methods.
	 */
	var Tracker = {};

	// http://docs.meteor.com/#tracker_active

	/**
	 * @summary True if there is a current computation, meaning that dependencies on reactive data sources will be tracked and potentially cause the current computation to be rerun.
	 * @locus Client
	 * @type {Boolean}
	 */
	Tracker.active = false;

	// http://docs.meteor.com/#tracker_currentcomputation

	/**
	 * @summary The current computation, or `null` if there isn't one.  The current computation is the [`Tracker.Computation`](#tracker_computation) object created by the innermost active call to `Tracker.autorun`, and it's the computation that gains dependencies when reactive data sources are accessed.
	 * @locus Client
	 * @type {Tracker.Computation}
	 */
	Tracker.currentComputation = null;

	// References to all computations created within the Tracker by id.
	// Keeping these references on an underscore property gives more control to
	// tooling and packages extending Tracker without increasing the API surface.
	// These can used to monkey-patch computations, their functions, use
	// computation ids for tracking, etc.
	Tracker._computations = {};

	var setCurrentComputation = function setCurrentComputation(c) {
	  Tracker.currentComputation = c;
	  Tracker.active = !!c;
	};

	var _debugFunc = function _debugFunc() {
	  // We want this code to work without Meteor, and also without
	  // "console" (which is technically non-standard and may be missing
	  // on some browser we come across, like it was on IE 7).
	  //
	  // Lazy evaluation because `Meteor` does not exist right away.(??)
	  return typeof Meteor !== "undefined" ? Meteor._debug : typeof console !== "undefined" && console.error ? function () {
	    console.error.apply(console, arguments);
	  } : function () {};
	};

	var _maybeSuppressMoreLogs = function _maybeSuppressMoreLogs(messagesLength) {
	  // Sometimes when running tests, we intentionally suppress logs on expected
	  // printed errors. Since the current implementation of _throwOrLog can log
	  // multiple separate log messages, suppress all of them if at least one suppress
	  // is expected as we still want them to count as one.
	  if (typeof Meteor !== "undefined") {
	    if (Meteor._suppressed_log_expected()) {
	      Meteor._suppress_log(messagesLength - 1);
	    }
	  }
	};

	var _throwOrLog = function _throwOrLog(from, e) {
	  if (throwFirstError) {
	    throw e;
	  } else {
	    var printArgs = ["Exception from Tracker " + from + " function:"];
	    if (e.stack && e.message && e.name) {
	      var idx = e.stack.indexOf(e.message);
	      if (idx < 0 || idx > e.name.length + 2) {
	        // check for "Error: "
	        // message is not part of the stack
	        var message = e.name + ": " + e.message;
	        printArgs.push(message);
	      }
	    }
	    printArgs.push(e.stack);
	    _maybeSuppressMoreLogs(printArgs.length);

	    for (var i = 0; i < printArgs.length; i++) {
	      _debugFunc()(printArgs[i]);
	    }
	  }
	};

	// Takes a function `f`, and wraps it in a `Meteor._noYieldsAllowed`
	// block if we are running on the server. On the client, returns the
	// original function (since `Meteor._noYieldsAllowed` is a
	// no-op). This has the benefit of not adding an unnecessary stack
	// frame on the client.
	var withNoYieldsAllowed = function withNoYieldsAllowed(f) {
	  if (typeof Meteor === 'undefined' || Meteor.isClient) {
	    return f;
	  } else {
	    return function () {
	      var args = arguments;
	      Meteor._noYieldsAllowed(function () {
	        f.apply(null, args);
	      });
	    };
	  }
	};

	var nextId = 1;
	// computations whose callbacks we should call at flush time
	var pendingComputations = [];
	// `true` if a Tracker.flush is scheduled, or if we are in Tracker.flush now
	var willFlush = false;
	// `true` if we are in Tracker.flush now
	var inFlush = false;
	// `true` if we are computing a computation now, either first time
	// or recompute.  This matches Tracker.active unless we are inside
	// Tracker.nonreactive, which nullfies currentComputation even though
	// an enclosing computation may still be running.
	var inCompute = false;
	// `true` if the `_throwFirstError` option was passed in to the call
	// to Tracker.flush that we are in. When set, throw rather than log the
	// first error encountered while flushing. Before throwing the error,
	// finish flushing (from a finally block), logging any subsequent
	// errors.
	var throwFirstError = false;

	var afterFlushCallbacks = [];

	var requireFlush = function requireFlush() {
	  if (!willFlush) {
	    // We want this code to work without Meteor, see debugFunc above
	    if (typeof Meteor !== "undefined") Meteor._setImmediate(Tracker._runFlush);else setTimeout(Tracker._runFlush, 0);
	    willFlush = true;
	  }
	};

	// Tracker.Computation constructor is visible but private
	// (throws an error if you try to call it)
	var constructingComputation = false;

	//
	// http://docs.meteor.com/#tracker_computation

	/**
	 * @summary A Computation object represents code that is repeatedly rerun
	 * in response to
	 * reactive data changes. Computations don't have return values; they just
	 * perform actions, such as rerendering a template on the screen. Computations
	 * are created using Tracker.autorun. Use stop to prevent further rerunning of a
	 * computation.
	 * @instancename computation
	 */
	Tracker.Computation = function (f, parent, onError) {
	  if (!constructingComputation) throw new Error("Tracker.Computation constructor is private; use Tracker.autorun");
	  constructingComputation = false;

	  var self = this;

	  // http://docs.meteor.com/#computation_stopped

	  /**
	   * @summary True if this computation has been stopped.
	   * @locus Client
	   * @memberOf Tracker.Computation
	   * @instance
	   * @name  stopped
	   */
	  self.stopped = false;

	  // http://docs.meteor.com/#computation_invalidated

	  /**
	   * @summary True if this computation has been invalidated (and not yet rerun), or if it has been stopped.
	   * @locus Client
	   * @memberOf Tracker.Computation
	   * @instance
	   * @name  invalidated
	   * @type {Boolean}
	   */
	  self.invalidated = false;

	  // http://docs.meteor.com/#computation_firstrun

	  /**
	   * @summary True during the initial run of the computation at the time `Tracker.autorun` is called, and false on subsequent reruns and at other times.
	   * @locus Client
	   * @memberOf Tracker.Computation
	   * @instance
	   * @name  firstRun
	   * @type {Boolean}
	   */
	  self.firstRun = true;

	  self._id = nextId++;
	  self._onInvalidateCallbacks = [];
	  self._onStopCallbacks = [];
	  // the plan is at some point to use the parent relation
	  // to constrain the order that computations are processed
	  self._parent = parent;
	  self._func = f;
	  self._onError = onError;
	  self._recomputing = false;

	  // Register the computation within the global Tracker.
	  Tracker._computations[self._id] = self;

	  var errored = true;
	  try {
	    self._compute();
	    errored = false;
	  } finally {
	    self.firstRun = false;
	    if (errored) self.stop();
	  }
	};

	// http://docs.meteor.com/#computation_oninvalidate

	/**
	 * @summary Registers `callback` to run when this computation is next invalidated, or runs it immediately if the computation is already invalidated.  The callback is run exactly once and not upon future invalidations unless `onInvalidate` is called again after the computation becomes valid again.
	 * @locus Client
	 * @param {Function} callback Function to be called on invalidation. Receives one argument, the computation that was invalidated.
	 */
	Tracker.Computation.prototype.onInvalidate = function (f) {
	  var self = this;

	  if (typeof f !== 'function') throw new Error("onInvalidate requires a function");

	  if (self.invalidated) {
	    Tracker.nonreactive(function () {
	      withNoYieldsAllowed(f)(self);
	    });
	  } else {
	    self._onInvalidateCallbacks.push(f);
	  }
	};

	/**
	 * @summary Registers `callback` to run when this computation is stopped, or runs it immediately if the computation is already stopped.  The callback is run after any `onInvalidate` callbacks.
	 * @locus Client
	 * @param {Function} callback Function to be called on stop. Receives one argument, the computation that was stopped.
	 */
	Tracker.Computation.prototype.onStop = function (f) {
	  var self = this;

	  if (typeof f !== 'function') throw new Error("onStop requires a function");

	  if (self.stopped) {
	    Tracker.nonreactive(function () {
	      withNoYieldsAllowed(f)(self);
	    });
	  } else {
	    self._onStopCallbacks.push(f);
	  }
	};

	// http://docs.meteor.com/#computation_invalidate

	/**
	 * @summary Invalidates this computation so that it will be rerun.
	 * @locus Client
	 */
	Tracker.Computation.prototype.invalidate = function () {
	  var self = this;
	  if (!self.invalidated) {
	    // if we're currently in _recompute(), don't enqueue
	    // ourselves, since we'll rerun immediately anyway.
	    if (!self._recomputing && !self.stopped) {
	      requireFlush();
	      pendingComputations.push(this);
	    }

	    self.invalidated = true;

	    // callbacks can't add callbacks, because
	    // self.invalidated === true.
	    for (var i = 0, f; f = self._onInvalidateCallbacks[i]; i++) {
	      Tracker.nonreactive(function () {
	        withNoYieldsAllowed(f)(self);
	      });
	    }
	    self._onInvalidateCallbacks = [];
	  }
	};

	// http://docs.meteor.com/#computation_stop

	/**
	 * @summary Prevents this computation from rerunning.
	 * @locus Client
	 */
	Tracker.Computation.prototype.stop = function () {
	  var self = this;

	  if (!self.stopped) {
	    self.stopped = true;
	    self.invalidate();
	    // Unregister from global Tracker.
	    delete Tracker._computations[self._id];
	    for (var i = 0, f; f = self._onStopCallbacks[i]; i++) {
	      Tracker.nonreactive(function () {
	        withNoYieldsAllowed(f)(self);
	      });
	    }
	    self._onStopCallbacks = [];
	  }
	};

	Tracker.Computation.prototype._compute = function () {
	  var self = this;
	  self.invalidated = false;

	  var previous = Tracker.currentComputation;
	  setCurrentComputation(self);
	  var previousInCompute = inCompute;
	  inCompute = true;
	  try {
	    withNoYieldsAllowed(self._func)(self);
	  } finally {
	    setCurrentComputation(previous);
	    inCompute = previousInCompute;
	  }
	};

	Tracker.Computation.prototype._needsRecompute = function () {
	  var self = this;
	  return self.invalidated && !self.stopped;
	};

	Tracker.Computation.prototype._recompute = function () {
	  var self = this;

	  self._recomputing = true;
	  try {
	    if (self._needsRecompute()) {
	      try {
	        self._compute();
	      } catch (e) {
	        if (self._onError) {
	          self._onError(e);
	        } else {
	          _throwOrLog("recompute", e);
	        }
	      }
	    }
	  } finally {
	    self._recomputing = false;
	  }
	};

	//
	// http://docs.meteor.com/#tracker_dependency

	/**
	 * @summary A Dependency represents an atomic unit of reactive data that a
	 * computation might depend on. Reactive data sources such as Session or
	 * Minimongo internally create different Dependency objects for different
	 * pieces of data, each of which may be depended on by multiple computations.
	 * When the data changes, the computations are invalidated.
	 * @class
	 * @instanceName dependency
	 */
	Tracker.Dependency = function () {
	  this._dependentsById = {};
	};

	// http://docs.meteor.com/#dependency_depend
	//
	// Adds `computation` to this set if it is not already
	// present.  Returns true if `computation` is a new member of the set.
	// If no argument, defaults to currentComputation, or does nothing
	// if there is no currentComputation.

	/**
	 * @summary Declares that the current computation (or `fromComputation` if given) depends on `dependency`.  The computation will be invalidated the next time `dependency` changes.

	If there is no current computation and `depend()` is called with no arguments, it does nothing and returns false.

	Returns true if the computation is a new dependent of `dependency` rather than an existing one.
	 * @locus Client
	 * @param {Tracker.Computation} [fromComputation] An optional computation declared to depend on `dependency` instead of the current computation.
	 * @returns {Boolean}
	 */
	Tracker.Dependency.prototype.depend = function (computation) {
	  if (!computation) {
	    if (!Tracker.active) return false;

	    computation = Tracker.currentComputation;
	  }
	  var self = this;
	  var id = computation._id;
	  if (!(id in self._dependentsById)) {
	    self._dependentsById[id] = computation;
	    computation.onInvalidate(function () {
	      delete self._dependentsById[id];
	    });
	    return true;
	  }
	  return false;
	};

	// http://docs.meteor.com/#dependency_changed

	/**
	 * @summary Invalidate all dependent computations immediately and remove them as dependents.
	 * @locus Client
	 */
	Tracker.Dependency.prototype.changed = function () {
	  var self = this;
	  for (var id in self._dependentsById) {
	    self._dependentsById[id].invalidate();
	  }
	};

	// http://docs.meteor.com/#dependency_hasdependents

	/**
	 * @summary True if this Dependency has one or more dependent Computations, which would be invalidated if this Dependency were to change.
	 * @locus Client
	 * @returns {Boolean}
	 */
	Tracker.Dependency.prototype.hasDependents = function () {
	  var self = this;
	  for (var id in self._dependentsById) {
	    return true;
	  }return false;
	};

	// http://docs.meteor.com/#tracker_flush

	/**
	 * @summary Process all reactive updates immediately and ensure that all invalidated computations are rerun.
	 * @locus Client
	 */
	Tracker.flush = function (options) {
	  Tracker._runFlush({ finishSynchronously: true,
	    throwFirstError: options && options._throwFirstError });
	};

	// Run all pending computations and afterFlush callbacks.  If we were not called
	// directly via Tracker.flush, this may return before they're all done to allow
	// the event loop to run a little before continuing.
	Tracker._runFlush = function (options) {
	  // XXX What part of the comment below is still true? (We no longer
	  // have Spark)
	  //
	  // Nested flush could plausibly happen if, say, a flush causes
	  // DOM mutation, which causes a "blur" event, which runs an
	  // app event handler that calls Tracker.flush.  At the moment
	  // Spark blocks event handlers during DOM mutation anyway,
	  // because the LiveRange tree isn't valid.  And we don't have
	  // any useful notion of a nested flush.
	  //
	  // https://app.asana.com/0/159908330244/385138233856
	  if (inFlush) throw new Error("Can't call Tracker.flush while flushing");

	  if (inCompute) throw new Error("Can't flush inside Tracker.autorun");

	  options = options || {};

	  inFlush = true;
	  willFlush = true;
	  throwFirstError = !!options.throwFirstError;

	  var recomputedCount = 0;
	  var finishedTry = false;
	  try {
	    while (pendingComputations.length || afterFlushCallbacks.length) {

	      // recompute all pending computations
	      while (pendingComputations.length) {
	        var comp = pendingComputations.shift();
	        comp._recompute();
	        if (comp._needsRecompute()) {
	          pendingComputations.unshift(comp);
	        }

	        if (!options.finishSynchronously && ++recomputedCount > 1000) {
	          finishedTry = true;
	          return;
	        }
	      }

	      if (afterFlushCallbacks.length) {
	        // call one afterFlush callback, which may
	        // invalidate more computations
	        var func = afterFlushCallbacks.shift();
	        try {
	          func();
	        } catch (e) {
	          _throwOrLog("afterFlush", e);
	        }
	      }
	    }
	    finishedTry = true;
	  } finally {
	    if (!finishedTry) {
	      // we're erroring due to throwFirstError being true.
	      inFlush = false; // needed before calling `Tracker.flush()` again
	      // finish flushing
	      Tracker._runFlush({
	        finishSynchronously: options.finishSynchronously,
	        throwFirstError: false
	      });
	    }
	    willFlush = false;
	    inFlush = false;
	    if (pendingComputations.length || afterFlushCallbacks.length) {
	      // We're yielding because we ran a bunch of computations and we aren't
	      // required to finish synchronously, so we'd like to give the event loop a
	      // chance. We should flush again soon.
	      if (options.finishSynchronously) {
	        throw new Error("still have more to do?"); // shouldn't happen
	      }
	      setTimeout(requireFlush, 10);
	    }
	  }
	};

	// http://docs.meteor.com/#tracker_autorun
	//
	// Run f(). Record its dependencies. Rerun it whenever the
	// dependencies change.
	//
	// Returns a new Computation, which is also passed to f.
	//
	// Links the computation to the current computation
	// so that it is stopped if the current computation is invalidated.

	/**
	 * @callback Tracker.ComputationFunction
	 * @param {Tracker.Computation}
	 */
	/**
	 * @summary Run a function now and rerun it later whenever its dependencies
	 * change. Returns a Computation object that can be used to stop or observe the
	 * rerunning.
	 * @locus Client
	 * @param {Tracker.ComputationFunction} runFunc The function to run. It receives
	 * one argument: the Computation object that will be returned.
	 * @param {Object} [options]
	 * @param {Function} options.onError Optional. The function to run when an error
	 * happens in the Computation. The only argument it recieves is the Error
	 * thrown. Defaults to the error being logged to the console.
	 * @returns {Tracker.Computation}
	 */
	Tracker.autorun = function (f, options) {
	  if (typeof f !== 'function') throw new Error('Tracker.autorun requires a function argument');

	  options = options || {};

	  constructingComputation = true;
	  var c = new Tracker.Computation(f, Tracker.currentComputation, options.onError);

	  if (Tracker.active) Tracker.onInvalidate(function () {
	    c.stop();
	  });

	  return c;
	};

	// http://docs.meteor.com/#tracker_nonreactive
	//
	// Run `f` with no current computation, returning the return value
	// of `f`.  Used to turn off reactivity for the duration of `f`,
	// so that reactive data sources accessed by `f` will not result in any
	// computations being invalidated.

	/**
	 * @summary Run a function without tracking dependencies.
	 * @locus Client
	 * @param {Function} func A function to call immediately.
	 */
	Tracker.nonreactive = function (f) {
	  var previous = Tracker.currentComputation;
	  setCurrentComputation(null);
	  try {
	    return f();
	  } finally {
	    setCurrentComputation(previous);
	  }
	};

	// http://docs.meteor.com/#tracker_oninvalidate

	/**
	 * @summary Registers a new [`onInvalidate`](#computation_oninvalidate) callback on the current computation (which must exist), to be called immediately when the current computation is invalidated or stopped.
	 * @locus Client
	 * @param {Function} callback A callback function that will be invoked as `func(c)`, where `c` is the computation on which the callback is registered.
	 */
	Tracker.onInvalidate = function (f) {
	  if (!Tracker.active) throw new Error("Tracker.onInvalidate requires a currentComputation");

	  Tracker.currentComputation.onInvalidate(f);
	};

	// http://docs.meteor.com/#tracker_afterflush

	/**
	 * @summary Schedules a function to be called during the next flush, or later in the current flush if one is in progress, after all invalidated computations have been rerun.  The function will be run once and not on subsequent flushes unless `afterFlush` is called again.
	 * @locus Client
	 * @param {Function} callback A function to call at flush time.
	 */
	Tracker.afterFlush = function (f) {
	  afterFlushCallbacks.push(f);
	  requireFlush();
	};

	module.exports = {
	  autorun: Tracker.autorun,
	  nonreactive: Tracker.nonreactive,
	  flush: Tracker.flush,
	  onInvalidate: Tracker.onInvalidate,
	  Dep: function Dep() {
	    return new Tracker.Dependency();
	  }
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// templates.js
	//
	// This file contains the reactive DOM implementation that is the core of Zodiac. It is the most complicated part, and I hope i will get around to writing some sort of explanation once it is 100%-ish finished.

	var tracker = __webpack_require__(1);

	var NodeInstance = function () {
	  function NodeInstance(nodeDefinition, parentNodeInstance) {
	    _classCallCheck(this, NodeInstance);

	    this.nodeDefinition = nodeDefinition;
	    this.parentNodeInstance = parentNodeInstance;
	    this.active = false;

	    if (parentNodeInstance) this.domParent = parentNodeInstance.dom ? parentNodeInstance : parentNodeInstance.domParent;

	    this.subConstructor(this);
	  }

	  _createClass(NodeInstance, [{
	    key: "toggle",
	    value: function toggle() {
	      this.active ? this.deactivate() : this.activate();
	    }
	  }, {
	    key: "activate",
	    value: function activate() {
	      if (this.active) throw "Already active.";
	      this._activate();
	      this.active = true;
	    }
	  }, {
	    key: "deactivate",
	    value: function deactivate() {
	      if (!this.active) throw "Already inactive.";
	      this._deactivate();
	      this.active = false;
	    }

	    // Returns the next active dom sibling after the current one. By active dom, i mean dom that is currently mounted somewhere beneath document.body.

	  }, {
	    key: "nextDomSibling",
	    value: function nextDomSibling() {
	      var r = this.domParent.domChildAfter(this);
	      if (r) return r.dom;
	    }
	  }, {
	    key: "domChildAfter",
	    value: function domChildAfter(target) {
	      var state = arguments.length <= 1 || arguments[1] === undefined ? { passed: false } : arguments[1];

	      if (!this.descendants) return;
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var d = _step.value;

	          // console.log(d);
	          if (state.passed) {
	            if (d.dom && d.active) {
	              // console.log("found next in flow");
	              return d;
	            }
	          } else if (d == target) {
	            // console.log("found");
	            state.passed = true;
	          }
	          if (d.constructor != TagNodeInstance) {
	            // console.log("descending");
	            var match = d.domChildAfter(target, state);
	            if (match) return match;
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	  }]);

	  return NodeInstance;
	}();

	// Mounting

	var Mounting = function (_NodeInstance) {
	  _inherits(Mounting, _NodeInstance);

	  function Mounting() {
	    _classCallCheck(this, Mounting);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Mounting).apply(this, arguments));
	  }

	  _createClass(Mounting, [{
	    key: "subConstructor",
	    value: function subConstructor() {
	      this.active = true;
	    }
	  }, {
	    key: "descendants",
	    value: function descendants() {
	      return [this.root];
	    }
	  }, {
	    key: "toggle",
	    value: function toggle() {
	      this.root.toggle();
	    }
	  }, {
	    key: "nextDomSibling",
	    value: function nextDomSibling() {
	      throw "A mounting does not have dom siblings.";
	    }
	  }]);

	  return Mounting;
	}(NodeInstance);

	function mount(dom, root) {
	  var m = new Mounting();
	  m.dom = dom;
	  m.root = root.render(m);
	  m.toggle();
	  return m;
	}

	// Text

	function TextNode(str) {
	  this.str = str;
	  this.isReactive = typeof str == "function";

	  this.render = function (parentNodeInstance) {
	    return new TextNodeInstance(this, parentNodeInstance);
	  };
	}

	function text(str) {
	  return new TextNode(str);
	}

	var TextNodeInstance = function (_NodeInstance2) {
	  _inherits(TextNodeInstance, _NodeInstance2);

	  function TextNodeInstance() {
	    _classCallCheck(this, TextNodeInstance);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(TextNodeInstance).apply(this, arguments));
	  }

	  _createClass(TextNodeInstance, [{
	    key: "subConstructor",
	    value: function subConstructor() {
	      this.dom = this.nodeDefinition.isReactive ? document.createTextNode("") : document.createTextNode(this.nodeDefinition.str);
	    }
	  }, {
	    key: "_activate",
	    value: function _activate() {
	      var _this3 = this;

	      if (this.nodeDefinition.isReactive) {
	        this.computation = tracker.autorun(function () {
	          _this3.dom.nodeValue = _this3.nodeDefinition.str();
	        });
	      }
	      this.domParent.dom.insertBefore(this.dom, this.nextDomSibling());
	    }
	  }, {
	    key: "_deactivate",
	    value: function _deactivate() {
	      if (this.nodeDefinition.isReactive) this.computation.stop();
	      this.domParent.dom.removeChild(this.dom);
	    }
	  }]);

	  return TextNodeInstance;
	}(NodeInstance);

	function _is(obj, kind) {
	  var toString = Object.prototype.toString;
	  return toString.call(obj) === ["[object ", kind, "]"].join("");
	}

	function tagify(obj) {
	  switch (typeof obj === "undefined" ? "undefined" : _typeof(obj)) {
	    case "string":
	    case "number":
	    case "function":
	      return text(obj);
	  }

	  if (_is(obj, "Array")) return list.apply(undefined, _toConsumableArray(obj.map(function (item) {
	    return tagify(item);
	  })));else return obj;
	}

	// List
	// This is exported as dom(...) in the official api.
	// It is called List here, because DomNode would be
	// wrong and confusing in this context.

	function ListNode(children) {
	  this.children = children.map(function (m) {
	    return tagify(m);
	  });

	  this.render = function (parentNodeInstance) {
	    return new ListNodeInstance(this, parentNodeInstance);
	  };
	}

	function list() {
	  for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {
	    children[_key] = arguments[_key];
	  }

	  return new ListNode(children);
	}

	var ListNodeInstance = function (_NodeInstance3) {
	  _inherits(ListNodeInstance, _NodeInstance3);

	  function ListNodeInstance() {
	    _classCallCheck(this, ListNodeInstance);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(ListNodeInstance).apply(this, arguments));
	  }

	  _createClass(ListNodeInstance, [{
	    key: "subConstructor",
	    value: function subConstructor() {
	      var _this5 = this;

	      this.children = this.nodeDefinition.children.map(function (m) {
	        return m.render(_this5);
	      });
	    }
	  }, {
	    key: "_activate",
	    value: function _activate() {
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = this.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var c = _step2.value;
	          c.activate();
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  }, {
	    key: "_deactivate",
	    value: function _deactivate() {
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = this.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var c = _step3.value;
	          c.deactivate();
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	    }
	  }, {
	    key: "descendants",
	    value: function descendants() {
	      return this.children;
	    }
	  }]);

	  return ListNodeInstance;
	}(NodeInstance);

	function TagNode(name, children) {
	  var _this6 = this;

	  var fc = children[0],
	      cls = void 0;
	  if (fc && typeof fc == "string" && fc[0] == ".") cls = children.shift();

	  this.name = name;
	  this.attrs = children[0] && children[0].constructor == Object ? children.shift() : {};
	  this.html = list.apply(undefined, _toConsumableArray(children));

	  if (cls) this.attrs[cls] = true;

	  this.classes = {};

	  Object.keys(this.attrs).forEach(function (k) {
	    if (k[0] == ".") {
	      k.slice(1).split(".").forEach(function (c) {
	        _this6.classes[c] = _this6.attrs[k];
	      });
	      delete _this6.attrs[k];
	    }
	  });

	  if (this.attrs.class) {
	    this.attrs.class.split(/\s+/).forEach(function (c) {
	      return _this6.classes[c] = true;
	    });
	    delete this.attrs.class;
	  }

	  this.render = function (parentNodeInstance) {
	    return new TagNodeInstance(this, parentNodeInstance);
	  };

	  this.getClassStr = function () {
	    var _this7 = this;

	    var result = [];
	    Object.keys(this.classes).forEach(function (k) {
	      var v = _this7.classes[k],
	          cond = typeof v == "function" ? v() : v;
	      if (cond) result.push(k);
	    });
	    return result.length ? result.join(" ") : undefined;
	  };
	}

	function tag(name) {
	  for (var _len2 = arguments.length, children = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    children[_key2 - 1] = arguments[_key2];
	  }

	  return new TagNode(name, children);
	}

	function checkAttr(k, v) {
	  if (k[0] == "$" || k[0] == "_") {
	    if (typeof v == "function") return "event";else {
	      console.log(v);
	      throw "Template event listener not a function: " + k;
	    }
	  }
	  if (typeof v == "function") return "reactive";
	  if (_is(v, "Array")) return "reactive";
	  return "static";
	}

	function reactiveAttrGetter(v) {
	  if (typeof v == "function") return v;
	  if (_is(v, "Array")) return function () {
	    return v.map(function (item) {
	      return typeof item == "function" ? item() : item;
	    }).join("");
	  };
	  return v;
	}

	var TagNodeInstance = function (_NodeInstance4) {
	  _inherits(TagNodeInstance, _NodeInstance4);

	  function TagNodeInstance() {
	    _classCallCheck(this, TagNodeInstance);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(TagNodeInstance).apply(this, arguments));
	  }

	  _createClass(TagNodeInstance, [{
	    key: "subConstructor",
	    value: function subConstructor() {
	      var _this9 = this;

	      this.dom = document.createElement(this.nodeDefinition.name);
	      this.html = this.nodeDefinition.html.render(this);

	      this._eachDefinitionAttr(function (k, v, kind) {
	        switch (kind) {
	          case "event":
	            _this9.dom.addEventListener(k.slice(1), function (e) {
	              return v(e);
	            }, k[0] == "$");
	            break;
	          case "static":
	            _this9._setAttr(k, v);
	        }
	      });
	    }
	  }, {
	    key: "_setAttr",
	    value: function _setAttr(k, v) {
	      if (k === "value") this.dom.value = v;
	      if (v === false || v === undefined || v === null) this.dom.removeAttribute(k);else this.dom.setAttribute(k, v);
	    }
	  }, {
	    key: "_eachDefinitionAttr",
	    value: function _eachDefinitionAttr(fn) {
	      var _this10 = this;

	      Object.keys(this.nodeDefinition.attrs).forEach(function (k) {
	        var v = _this10.nodeDefinition.attrs[k];
	        fn(k, v, checkAttr(k, v));
	      });
	    }
	  }, {
	    key: "_sendEvent",
	    value: function _sendEvent(name) {
	      var ev = document.createEvent('Event');
	      ev.initEvent(name, false, true);
	      this.dom.dispatchEvent(ev);
	    }
	  }, {
	    key: "_activate",
	    value: function _activate() {
	      var _this11 = this;

	      this.computations = [];
	      this._eachDefinitionAttr(function (k, v, kind) {
	        if (kind === "reactive") {
	          (function () {
	            var getter = reactiveAttrGetter(v);
	            _this11.computations.push(tracker.autorun(function () {
	              return _this11._setAttr(k, getter());
	            }));
	          })();
	        }
	      });

	      this.computations.push(tracker.autorun(function () {
	        return _this11._setAttr("class", _this11.nodeDefinition.getClassStr());
	      }));

	      this.html.activate();
	      this.domParent.dom.insertBefore(this.dom, this.nextDomSibling());
	      this._sendEvent("_activated");
	    }
	  }, {
	    key: "_deactivate",
	    value: function _deactivate() {
	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;

	      try {
	        for (var _iterator4 = this.computations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var c = _step4.value;
	          c.stop();
	        }
	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }

	      this.domParent.dom.removeChild(this.dom);
	      this.html.deactivate();
	    }
	  }, {
	    key: "descendants",
	    value: function descendants() {
	      return [this.html];
	    }
	  }]);

	  return TagNodeInstance;
	}(NodeInstance);

	// Cond

	function CondNode(check, a, b) {
	  this.check = check;
	  this.a = tagify(a);
	  if (b) this.b = tagify(b);

	  this.render = function (parentNodeInstance) {
	    return new CondNodeInstance(this, parentNodeInstance);
	  };
	}

	function cond(check, a, b) {
	  return new CondNode(check, a, b);
	}

	var CondNodeInstance = function (_NodeInstance5) {
	  _inherits(CondNodeInstance, _NodeInstance5);

	  function CondNodeInstance() {
	    _classCallCheck(this, CondNodeInstance);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(CondNodeInstance).apply(this, arguments));
	  }

	  _createClass(CondNodeInstance, [{
	    key: "subConstructor",
	    value: function subConstructor() {
	      this.a = this.nodeDefinition.a.render(this);
	      if (this.nodeDefinition.b) this.b = this.nodeDefinition.b.render(this);
	    }
	  }, {
	    key: "checkState",
	    value: function checkState() {
	      var chk = this.nodeDefinition.check;
	      return !!(typeof chk == "function" ? chk() : chk);
	    }
	  }, {
	    key: "_activate",
	    value: function _activate() {
	      var _this13 = this;

	      this.computation = tracker.autorun(function () {
	        _this13.state = _this13.checkState();
	        if (_this13.state != _this13.a.active) _this13.a.toggle();
	        if (_this13.b && _this13.state == _this13.b.active) _this13.b.toggle();
	      });
	    }
	  }, {
	    key: "_deactivate",
	    value: function _deactivate() {
	      this.computation.stop();
	      if (this.a.active) this.a.deactivate();
	      if (this.b && this.b.active) this.b.deactivate();
	    }
	  }, {
	    key: "descendants",
	    value: function descendants() {
	      var r = [this.a];
	      if (this.b) r.push(this.b);
	      return r;
	    }
	  }]);

	  return CondNodeInstance;
	}(NodeInstance);

	function _castArray() {
	  if (!arguments.length) return [];
	  var value = arguments[0];
	  return _is(value, "Array") ? value : [value];
	}

	// Dynamic (aka loop)

	function DynamicNode(listSource, remapFunc) {
	  var _this14 = this;

	  this.isReactive = typeof listSource == "function";
	  this.listSource = listSource;
	  this.remapFunc = remapFunc || function (v) {
	    return v;
	  };
	  if (typeof this.remapFunc != "function") {
	    console.log(this.remapFunc);
	    throw new Error("second argument for dynamic must be a function if present");
	  }

	  this.render = function (parentNodeInstance) {
	    return new DynamicNodeInstance(this, parentNodeInstance);
	  };

	  var _source = function _source() {
	    var ls = _this14.listSource;
	    return _castArray(typeof ls == "function" ? ls() : ls);
	  };

	  this._mapBody = function (instance) {
	    var _this15 = this;

	    var i = 0;
	    return _source().map(function (m) {
	      return tagify(_this15.remapFunc(m, i++)).render(instance);
	    });
	  };
	}

	function dynamic(listSource, remapFunc) {
	  return new DynamicNode(listSource, remapFunc);
	}

	var DynamicNodeInstance = function (_NodeInstance6) {
	  _inherits(DynamicNodeInstance, _NodeInstance6);

	  function DynamicNodeInstance() {
	    _classCallCheck(this, DynamicNodeInstance);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(DynamicNodeInstance).apply(this, arguments));
	  }

	  _createClass(DynamicNodeInstance, [{
	    key: "subConstructor",
	    value: function subConstructor() {
	      var ndf = this.nodeDefinition;
	      if (!ndf.isReactive) this.bodyInstances = ndf._mapBody(this);
	    }
	  }, {
	    key: "_activate",
	    value: function _activate() {
	      var _this17 = this;

	      var ndf = this.nodeDefinition;
	      if (ndf.isReactive) {
	        // TODO: cut & update implementation
	        this.computation = tracker.autorun(function () {
	          if (_this17.active) {
	            var _iteratorNormalCompletion5 = true;
	            var _didIteratorError5 = false;
	            var _iteratorError5 = undefined;

	            try {
	              for (var _iterator5 = _this17.bodyInstances[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	                var c = _step5.value;
	                c.deactivate();
	              }
	            } catch (err) {
	              _didIteratorError5 = true;
	              _iteratorError5 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                  _iterator5.return();
	                }
	              } finally {
	                if (_didIteratorError5) {
	                  throw _iteratorError5;
	                }
	              }
	            }
	          }_this17.bodyInstances = ndf._mapBody(_this17);
	          var _iteratorNormalCompletion6 = true;
	          var _didIteratorError6 = false;
	          var _iteratorError6 = undefined;

	          try {
	            for (var _iterator6 = _this17.bodyInstances[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	              var c = _step6.value;
	              c.activate();
	            }
	          } catch (err) {
	            _didIteratorError6 = true;
	            _iteratorError6 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                _iterator6.return();
	              }
	            } finally {
	              if (_didIteratorError6) {
	                throw _iteratorError6;
	              }
	            }
	          }
	        });
	      } else {
	        var _iteratorNormalCompletion7 = true;
	        var _didIteratorError7 = false;
	        var _iteratorError7 = undefined;

	        try {
	          for (var _iterator7 = this.bodyInstances[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	            var b = _step7.value;
	            b.activate();
	          }
	        } catch (err) {
	          _didIteratorError7 = true;
	          _iteratorError7 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion7 && _iterator7.return) {
	              _iterator7.return();
	            }
	          } finally {
	            if (_didIteratorError7) {
	              throw _iteratorError7;
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: "_deactivate",
	    value: function _deactivate() {
	      if (this.computation) this.computation.stop();
	      var _iteratorNormalCompletion8 = true;
	      var _didIteratorError8 = false;
	      var _iteratorError8 = undefined;

	      try {
	        for (var _iterator8 = this.bodyInstances[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	          var b = _step8.value;
	          b.deactivate();
	        }
	      } catch (err) {
	        _didIteratorError8 = true;
	        _iteratorError8 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion8 && _iterator8.return) {
	            _iterator8.return();
	          }
	        } finally {
	          if (_didIteratorError8) {
	            throw _iteratorError8;
	          }
	        }
	      }
	    }
	  }, {
	    key: "descendants",
	    value: function descendants() {
	      return this.bodyInstances || [];
	    }
	  }]);

	  return DynamicNodeInstance;
	}(NodeInstance);

	module.exports = {
	  mount: mount, text: text, tag: tag, cond: cond, dynamic: dynamic,
	  dom: list
	};

	// html, head and body are not included.
	var tags = 'a abbr address article aside audio b bdi bdo blockquote button canvas caption cite code colgroup datalist dd del details dfn div dl dt em fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 header hgroup i iframe ins kbd label legend li map mark menu meter nav noscript object ol optgroup option output p pre progress q rp rt ruby s samp script section select small span strong style sub summary sup table tbody td textarea tfoot th thead time title tr u ul video applet acronym bgsound dir frameset noframes isindex area base br col command embed hr img input keygen link meta param source track wbr basefont frame applet acronym bgsound dir frameset noframes isindex listing nextid noembed plaintext rb strike xmp big blink center font marquee multicol nobr spacer tt basefont frame'.split(" ");

	var _iteratorNormalCompletion9 = true;
	var _didIteratorError9 = false;
	var _iteratorError9 = undefined;

	try {
	  for (var _iterator9 = tags[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	    var t = _step9.value;

	    module.exports[t] = function (t) {
	      return function () {
	        return tag.apply(undefined, [t].concat(Array.prototype.slice.call(arguments)));
	      };
	    }(t);
	  }
	} catch (err) {
	  _didIteratorError9 = true;
	  _iteratorError9 = err;
	} finally {
	  try {
	    if (!_iteratorNormalCompletion9 && _iterator9.return) {
	      _iterator9.return();
	    }
	  } finally {
	    if (_didIteratorError9) {
	      throw _iteratorError9;
	    }
	  }
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.Follow = Follow;

	var _require = __webpack_require__(1);

	var Dep = _require.Dep;
	var autorun = _require.autorun;

	// variables.js
	//
	// Reactive variable implmentations based on Tracker,
	// and some JavaScript helpers.
	//
	// We avoid `this` altogether here, in order to be able to pass
	// all the methods freely around. This is important in order to
	// avoid template boilerplate.

	function shortcut(kind) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return new (Function.prototype.bind.apply(kind, [null].concat(args)))();
	  };
	}

	var $ = exports.$ = shortcut(ZVar),
	    Dict = exports.Dict = shortcut(ZDict);

	// Return a reactive variable, which tracks changes using tracker,
	// so that it functions as a reactive source.
	function ZVar(value) {
	  var dep = Dep(),
	      defaultValue = value;

	  // Return the current value of the variable
	  function get() {
	    dep.depend();
	    return value;
	  }

	  // Set the current value of the variable
	  function set(val) {
	    if (value === val) return;
	    value = val;
	    dep.changed();
	  }

	  // Depend reactively on this variable inside tracker.autorun.
	  function depend() {
	    dep.depend();
	  }

	  // Reset this variable to the value that was initially
	  // passed to the constructor.
	  function reset() {
	    set(defaultValue);
	  }

	  // Boolean convenience method.
	  function toggle() {
	    set(!value);
	  }

	  // Integer convenience method.
	  function inc() {
	    dep.changed();
	    return ++value;
	  }

	  // Integer convenience method.
	  function dec() {
	    dep.changed();
	    return --value;
	  }

	  // Array convenience method.
	  function push(val) {
	    dep.changed();
	    value.push(val);
	  }

	  // Array convenience method.
	  function pop(val) {
	    if (value.length > 0) dep.changed();
	    return value.pop();
	  }

	  // Array convenience method.
	  function unshift(val) {
	    dep.changed();
	    value.unshift(val);
	  }

	  // Array convenience method.
	  function shift(val) {
	    if (value.length > 0) dep.changed();
	    return value.shift();
	  }

	  // Array convenience method
	  function length() {
	    dep.depend();
	    return value.length;
	  }

	  // Array convenience method
	  function filter(fn) {
	    value = value.filter(fn);
	    dep.changed();
	  }

	  // Array convenience method
	  function drop(item) {
	    filter(function (e) {
	      return e !== item;
	    });
	  }

	  // Reset this variable, and return the value that was overwritten.
	  function consume() {
	    var result = value;
	    reset();
	    return result;
	  }

	  Object.assign(this, {
	    set: set, depend: depend, get: get,
	    reset: reset, consume: consume,
	    toggle: toggle,
	    inc: inc, dec: dec,
	    push: push, pop: pop, unshift: unshift, shift: shift, length: length, filter: filter, drop: drop
	  });
	}

	// Reactive dictionary. Experimental feature.
	function ZDict(_vals) {
	  var deps = {},
	      vals = _extends({}, _vals);

	  function set(name, val) {
	    if (vals[name] === val) return;
	    deps[name] = deps[name] || Dep();
	    deps[name].changed();
	    vals[name] = val;
	  }

	  function get(name) {
	    deps[name] = deps[name] || Dep();
	    deps[name].depend();
	    return vals[name];
	  }
	  Object.assign(this, {
	    set: set, get: get
	  });
	}

	// Returns a reactive variable that will change to the value of a reactive getter whenever the getter changes. It can however be set to other values inbetween, without affecting the source of the getter.
	function Follow(getter) {
	  var result = $(1);
	  autorun(function () {
	    return result.set(getter());
	  });
	  return result;
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.LocalStorage = LocalStorage;
	exports.deserialize = deserialize;
	exports.dump = dump;

	var _require = __webpack_require__(1);

	var autorun = _require.autorun;

	var _require2 = __webpack_require__(3);

	var $ = _require2.$;

	// Provides saving, reloading and save state tracking of a reactive variable given a getter and a setter to persist and load the state.
	//  Note that the Persister will not mark the item changed until the tracker has flushed. you have to flush before checking for changes. This is usually not a problem in practice as long as the architecture is good.

	function Persist(state, _ref) {
	  var load = _ref.load;
	  var _save = _ref.save;

	  var saved = $(false);
	  state.set(load());

	  autorun(function () {
	    state.depend();
	    saved.set(false);
	  });

	  saved.set(true);

	  return {
	    save: function save() {
	      _save(state);
	      saved.set(true);
	    },
	    reload: function reload() {
	      return state.set(load());
	    },
	    saved: saved
	  };
	}

	// localStorage adapter that can be used with Persist
	exports.Persist = Persist;
	function LocalStorage(key) {
	  return {
	    load: function load() {
	      var val = localStorage.getItem(key);
	      return val === undefined ? undefined : JSON.parse(val);
	    },

	    save: function save(state) {
	      return localStorage.setItem(key, JSON.stringify(state));
	    }
	  };
	}

	function _is(obj, kind) {
	  var toString = Object.prototype.toString;
	  return toString.call(obj) === ["[object ", kind, "]"].join("");
	}

	function deserialize(val) {
	  if (val == "__$isZUNDEF") return undefined;
	  if (val.__$isZV === 1) return $(deserialize(val.v));else if (_is(val, "Array")) return val.map(deserialize);else if (val.constructor === Object) {
	    var _ret = function () {
	      var result = {};
	      Object.keys(val).forEach(function (k) {
	        return result[k] = deserialize(val[k]);
	      });
	      return {
	        v: result
	      };
	    }();

	    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
	  } else return val;
	}

	function dump(val) {
	  if (val == undefined) return "__$isZUNDEF";
	  if (val.constructor.name === "ZVar") return {
	    __$isZV: 1,
	    v: dump(val.get())
	  };else if (_is(val, "Array")) return val.map(dump);else if (val.constructor === Object) {
	    var _ret2 = function () {
	      var result = {};
	      Object.keys(val).forEach(function (k) {
	        return result[k] = dump(val[k]);
	      });
	      return {
	        v: result
	      };
	    }();

	    if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
	  } else return val;
	}

	// Serializer that can wrap a reactive variable in order
	// to convert its underlying structure to valid JSON.

	function SerializeTo(_ref2) {
	  var _load = _ref2.load;
	  var _save2 = _ref2.save;

	  return {
	    load: function load() {
	      return deserialize(_load());
	    },
	    save: function save(val) {
	      return _save2(dump(val));
	    }
	  };
	}
	exports.SerializeTo = SerializeTo;

/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IntervalTimer = IntervalTimer;
	exports.targetValue = targetValue;
	exports.ifEnter = ifEnter;

	// Various helpful utility functions that become available right
	// on the Zodiac object.

	// More convenient dom timer syntax. Uses a regular timer.
	function ZIntervalTimer(interval, callback) {
	  var timer = window.setInterval(callback, interval);
	  return {
	    stop: function stop() {
	      window.clearInterval(timer);
	    }
	  };
	}

	function IntervalTimer() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return new (Function.prototype.bind.apply(ZIntervalTimer, [null].concat(args)))();
	}

	// Experimental: Wrap an event callback to receive the target value.
	function targetValue(fn) {
	  return function (ev) {
	    fn(ev.target.value);
	  };
	}

	// Experimental: Wrap an event callback to only receive enter presses.
	function ifEnter(fn) {
	  return function (ev) {
	    if (ev.keyCode === 13) fn(ev);
	  };
	}

/***/ }
/******/ ]);